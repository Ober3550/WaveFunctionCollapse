<html>
  <head>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.4.1/lib/p5.js"></script>
    <script>
      const tileImages = [];
      const IMAGE_COUNT = 7;
      const IMAGE_SIZE_PX = 14;
      const DIM = 50;
      const TILES_PER_FRAME = 10;
      const SHOW_VALID_COUNT = false;
      const CANVAS_WIDTH = 700;
      const CANVAS_HEIGHT = 700;
      const UP = 0;
      const RIGHT = 1;
      const DOWN = 2;
      const LEFT = 3;
      const LOGGING = false;
      const WRAP_AROUND = false;
      let running = true;
      let tileWidth;
      let tileHeight;

      let tiles = [];
      let eventStack = [];
      let tileRules = [];

      function preload() {
        const directory = "new_circuit";
        for (let i = 0; i <= IMAGE_COUNT; i++) {
          tileImages[i] = loadImage(`${directory}/${i}.png`);
        }
      }

      class TileRule {
        constructor(image_idx, edges = [[], [], [], []], rotation = 0) {
          this.image_idx = image_idx;
          this.edges = edges;
          this.rotation = rotation;
          if (rotation == 0) {
            // Generate edge definition from image pixels
            loadPixels();
            let loadImage = tileImages[image_idx];
            if (loadImage != null) {
              loadImage.loadPixels();
              for (let i = 0; i < loadImage.width; i++) {
                this.edges[UP].push(loadImage.get(i, 0));
                this.edges[DOWN].push(loadImage.get(i, loadImage.height - 1));
              }
              for (let j = 0; j < loadImage.height; j++) {
                this.edges[RIGHT].push(loadImage.get(loadImage.width - 1, j));
                this.edges[LEFT].push(loadImage.get(0, j));
              }
            }
          }
          // Create set of allowed adjacent tile sets
          this.up = [];
          this.right = [];
          this.down = [];
          this.left = [];
        }
        rotate(num) {
          let newEdges = [];
          for (let i = 0; i < this.edges.length; i++) {
            let newEdge = i;
            let oldEdge = (i - num + 4) % 4;
            // If the difference between the old edge and the new edge is on one of these boundaries
            // Reverse the order of the pixels
            if ((oldEdge < 2 && newEdge > 1) || (oldEdge > 1 && newEdge < 2)) {
              newEdges[newEdge] = [];
              for (let j = this.edges[oldEdge].length - 1; j >= 0; j--) {
                newEdges[newEdge].push(this.edges[oldEdge][j]);
              }
            } else {
              newEdges[newEdge] = this.edges[oldEdge];
            }
          }
          return new TileRule(this.image_idx, newEdges, num);
        }
        calculateAdjacency() {
          // Sets up the adjacency rules within the classes
          for (let i = 0; i < tileRules.length; i++) {
            if (tileRules[i] != null) {
              if (checkArrays(this.edges[UP], tileRules[i].edges[DOWN])) {
                this.up.push(i);
              }
              if (checkArrays(this.edges[DOWN], tileRules[i].edges[UP])) {
                this.down.push(i);
              }
              if (checkArrays(this.edges[RIGHT], tileRules[i].edges[LEFT])) {
                this.right.push(i);
              }
              if (checkArrays(this.edges[LEFT], tileRules[i].edges[RIGHT])) {
                this.left.push(i);
              }
            }
          }
        }
      }

      function checkArrays(arrA, arrB) {
        if (arrA.length != arrB.length) return false;
        for (let i = 0; i < arrA.length; i++) {
          if (arrA[i] instanceof Array) {
            if (checkArrays(arrA[i], arrB[i]) == false) return false;
          } else {
            if (arrA[i] != arrB[i]) return false;
          }
        }
        return true;
      }

      class Tile {
        constructor(i, j) {
          this.i = i;
          this.j = j;
          this.validTiles = [...Array(tileRules.length).keys()];
          this.backtrackInvalid = [];
          this.collapsed = false;
        }
        draw(i, j) {
          if (this.collapsed && this.validTiles.length > 0) {
            let tileRule = tileRules[this.validTiles[0]];
            if (tileRule != null) {
              let tileImage = tileImages[tileRule.image_idx];
              let rotation = tileRule.rotation;
              // Make grid tiles overlap edges
              let tileX = tileWidth * i - (tileWidth / IMAGE_SIZE_PX) * i;
              let tileY = tileHeight * j - (tileHeight / IMAGE_SIZE_PX) * j;
              imageMode(CENTER);
              translate(tileX + tileWidth / 2, tileY + tileHeight / 2);
              rotate((PI / 2) * rotation);
              image(tileImage, 0, 0, tileWidth, tileHeight);
              rotate((-PI / 2) * rotation);
              translate(-(tileX + tileWidth / 2), -(tileY + tileHeight / 2));
              imageMode(CORNER);
            }
          } else {
            if (SHOW_VALID_COUNT)
              text(
                this.validTiles.length.toString(),
                tileWidth * i + tileWidth / 2 - (tileWidth / IMAGE_SIZE_PX) * i,
                tileHeight * j +
                  tileHeight / 2 -
                  (tileHeight / IMAGE_SIZE_PX) * j
              );
          }
        }
      }

      function setup() {
        createCanvas(CANVAS_WIDTH, CANVAS_HEIGHT);
        noSmooth();
        for (let i = 0; i < tileImages.length; i++) {
          tileRules[i] = new TileRule(i);
        }
        for (let i = 0; i < tileImages.length; i++) {
          for (let j = 1; j <= 3; j++) {
            tileRules.push(tileRules[i].rotate(j));
          }
        }
        for (let i = 0; i < tileRules.length; i++) {
          if (tileRules[i] != null) {
            tileRules[i].calculateAdjacency();
          }
        }
        if (LOGGING) console.log(tileRules);
        let fill = 1 + 1 / IMAGE_SIZE_PX;
        tileWidth = (width * fill) / DIM;
        tileHeight = (height * fill) / DIM;
        for (let j = 0; j < DIM; j++) {
          for (let i = 0; i < DIM; i++) {
            tiles.push(new Tile(i, j));
          }
        }
      }

      function checkNeighbors(x, y, resetBacktracking = true) {
        if (WRAP_AROUND) {
          if (x < 0) x = DIM - 1;
          if (x >= DIM) x = 0;
          if (y < 0) y = DIM - 1;
          if (y >= DIM) y = 0;
        }
        // Reduce the entropy of neighbors
        if (x >= 0 && x < DIM && y >= 0 && y < DIM) {
          let currentTile = tiles[y * DIM + x];
          if (currentTile.collapsed == false) {
            currentTile.validTiles = [...Array(tileRules.length).keys()];
            if(resetBacktracking)
                currentTile.backtrackInvalid = [];
            currentTile.validTiles = currentTile.validTiles.filter((tile) => {
              for (let i = 0; i < currentTile.backtrackInvalid.length; i++) {
                if (tile == currentTile.backtrackInvalid[i]) return false;
              }
              return true;
            });
            let neighborX = x;
            let neighborY = y;

            neighborX = x;
            neighborY = y - 1;
            if (WRAP_AROUND && neighborY == -1) neighborY = DIM - 1;
            if (neighborY >= 0) {
              let neighbor = tiles[neighborY * DIM + neighborX];
              if (neighbor.collapsed) {
                let neighborRules = tileRules[neighbor.validTiles[0]];
                currentTile.validTiles = currentTile.validTiles.filter(
                  (tile) => {
                    return neighborRules.down.includes(tile);
                  }
                );
              }
            }
            neighborX = x + 1;
            neighborY = y;
            if (WRAP_AROUND && neighborX == DIM) neighborX = 0;
            if (neighborX < DIM) {
              let neighbor = tiles[neighborY * DIM + neighborX];
              if (neighbor.collapsed) {
                let neighborRules = tileRules[neighbor.validTiles[0]];
                currentTile.validTiles = currentTile.validTiles.filter(
                  (tile) => {
                    return neighborRules.left.includes(tile);
                  }
                );
              }
            }
            neighborX = x;
            neighborY = y + 1;
            if (WRAP_AROUND && neighborY == DIM) neighborY = 0;
            if (neighborY < DIM) {
              let neighbor = tiles[neighborY * DIM + neighborX];
              if (neighbor.collapsed) {
                let neighborRules = tileRules[neighbor.validTiles[0]];
                currentTile.validTiles = currentTile.validTiles.filter(
                  (tile) => {
                    return neighborRules.up.includes(tile);
                  }
                );
              }
            }
            neighborX = x - 1;
            neighborY = y;
            if (WRAP_AROUND && neighborX == -1) neighborX = DIM - 1;
            if (neighborX >= 0) {
              let neighbor = tiles[neighborY * DIM + neighborX];
              if (neighbor.collapsed) {
                let neighborRules = tileRules[neighbor.validTiles[0]];
                currentTile.validTiles = currentTile.validTiles.filter(
                  (tile) => {
                    return neighborRules.right.includes(tile);
                  }
                );
              }
            }
            if (currentTile.validTiles.length == 0) {
              return false;
            }
          }
        }
        return true;
      }

      let hover = "";
      function mouseMoved() {
        let gridX = Math.floor((mouseX / tileWidth) * (1 - 1 / IMAGE_SIZE_PX));
        let gridY = Math.floor((mouseY / tileHeight) * (1 - 1 / IMAGE_SIZE_PX));
        if (gridX >= 0 && gridX < DIM && gridY >= 0 && gridY < DIM) {
          let tile = tiles[gridY * DIM + gridX];
          let tileRule;
          let metadata = "";
          if (tile.validTiles.length == 1) {
            tileRule = tileRules[tile.validTiles[0]];
            metadata = `tile: ${tile.validTiles[0]}`;
          } else {
            metadata = `validTiles: [${tile.validTiles}]`;
          }
          hover = `x: ${gridX}, y: ${gridY}\n${metadata}`;
        } else {
          hover = "";
        }
      }
      let valid = [];
      let allValid = true;
      function draw() {
        background(100);
        // Draw all the tiles
        for (let j = 0; j < DIM; j++) {
          for (let i = 0; i < DIM; i++) {
            if (j * DIM + i < tiles.length) {
              tiles[j * DIM + i].draw(i, j);
            }
          }
        }
        fill(255);
        textSize(20);
        textStyle(BOLD);
        let debugX = mouseX;
        let debugY = mouseY;
        if (mouseX > width - 100) {
          debugX -= 100;
        }
        if (mouseY > height - 100) {
          debugY -= 100;
        }
        text(hover, debugX, debugY);

        for (let f = 0; f < TILES_PER_FRAME; f++) {
          if (running) {
            if (allValid) {
              // Pick a random tile to collapse
              let tilesCopy = tiles.slice();
              tilesCopy = tilesCopy.sort((a, b) => {
                return a.validTiles.length - b.validTiles.length;
              });
              tilesCopy = tilesCopy.filter((element) => {
                return (
                  element.validTiles.length > 1 || element.collapsed == false
                );
              });
              tilesCopy = tilesCopy.filter((element) => {
                return (
                  element.validTiles.length == tilesCopy[0].validTiles.length
                );
              });
              if (tilesCopy.length > 0) {
                let tile = random(tilesCopy);
                let selectedTile = random(tile.validTiles);
                if (selectedTile != null) {
                  tile.validTiles = [selectedTile];
                  tile.collapsed = true;
                  eventStack.push({
                    i: tile.i,
                    j: tile.j,
                    selected: selectedTile,
                  });
                  if (LOGGING)
                    console.log(
                      `Pushed: ${JSON.stringify(
                        eventStack[eventStack.length - 1]
                      )}`
                    );
                } else {
                  tile.validTiles = [];
                }
                valid = [
                  checkNeighbors(tile.i, tile.j, false),
                  checkNeighbors(tile.i, tile.j - 1),
                  checkNeighbors(tile.i, tile.j + 1),
                  checkNeighbors(tile.i - 1, tile.j),
                  checkNeighbors(tile.i + 1, tile.j),
                ];
                allValid = true;
                for (let i = 0; i < valid.length; i++) {
                  if (valid[i] == false) {
                    allValid = false;
                  }
                }
              }
            } else {
              // Revert previous changes
              event = eventStack.pop();
              if (LOGGING) console.log(`Reversed: ${JSON.stringify(event)}`);
              let lastTile = tiles[event.j * DIM + event.i];
              lastTile.collapsed = false;
              let alreadyAdded = false;
              for (let i = 0; i < lastTile.backtrackInvalid.length; i++) {
                if (lastTile.backtrackInvalid[i] == event.selected) {
                  alreadyAdded = true;
                }
              }
              if (!alreadyAdded) lastTile.backtrackInvalid.push(event.selected);
              valid = [
                checkNeighbors(event.i, event.j, false),
                checkNeighbors(event.i, event.j - 1),
                checkNeighbors(event.i, event.j + 1),
                checkNeighbors(event.i - 1, event.j),
                checkNeighbors(event.i + 1, event.j),
              ];
              allValid = true;
              for (let i = 0; i < valid.length; i++) {
                if (valid[i] == false) {
                  allValid = false;
                }
              }
            }
          }
        }

        //noLoop();
      }
    </script>
  </head>
  <body>
    <main></main>
  </body>
</html>
